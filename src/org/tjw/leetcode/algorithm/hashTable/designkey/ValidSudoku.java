package org.tjw.leetcode.algorithm.hashTable.designkey;


public class ValidSudoku {

    public static void main(String[] args) {
        Solution solution = new ValidSudoku().new Solution();

        // 问题1 出现错误 应该false
        char[][] maps2 =
                {{'7','.','.', '.','4','.', '.','.','.'}
                ,{'.','.','.', '8','6','5', '.','.','.'}
                ,{'.','1','.', '2','.','.', '.','.','.'}

                ,{'.','.','.', '.','.','9', '.','.','.'}
                ,{'.','.','.', '.','5','.', '5','.','.'}
                ,{'.','.','.', '.','.','.', '.','.','.'}

                ,{'.','.','.', '.','.','.', '2','.','.'}
                ,{'.','.','.', '.','.','.', '.','.','.'}
                ,{'.','.','.', '.','.','.', '.','.','.'}};

        // 问题2 如果出现全都是'.'的话应该判错false
        char[][] maps3 =
       {{'.','.','.', '.','5','.', '.','1','.'},
        {'.','4','.', '3','.','.', '.','.','.'},
        {'.','.','.', '.','.','3', '.','.','1'},

        {'8','.','.', '.','.','.', '.','2','.'},
        {'.','.','2', '.','7','.', '.','.','.'},
        {'.','1','5', '.','.','.', '.','.','.'},

        {'.','.','.', '.','.','2', '.','.','.'},
        {'.','2','.', '9','.','.', '.','.','.'},
        {'.','.','4', '.','.','.', '.','.','.'}};

        // 问题3 如果全部'.'反而要true
        char[][] maps4 =
        {{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}
        ,{'.','.','.','.','.','.','.','.','.'}};

        // 问题4 如果横竖两个是'.'true
        char[][] maps5 =
        {{'.','.','5', '.','.','.', '.','.','6'}
        ,{'.','.','.', '.','1','4', '.','.','.'}
        ,{'.','.','.', '.','.','.', '.','.','.'}

        ,{'.','.','.', '.','.','9', '2','.','.'}
        ,{'5','.','.', '.','.','2', '.','.','.'}
        ,{'.','.','.', '.','.','.', '.','3','.'}

        ,{'.','.','.', '5','4','.', '.','.','.'}
        ,{'3','.','.', '.','.','.', '4','2','.'}
        ,{'.','.','.', '2','7','.', '6','.','.'}};

        // 问题5 数独还有个子框，里面都是'.'也不行，干脆重新写算法
        char[][] maps6 =
        {{'.','.','.', '.','8','.', '.','.','.'}
        ,{'.','.','.', '.','.','.', '5','.','.'}
        ,{'.','.','.', '.','4','.', '.','2','.'}

        ,{'.','.','.', '3','.','9', '.','.','.'}
        ,{'.','.','1', '8','.','.', '9','.','.'}
        ,{'.','.','.', '.','.','5', '1','.','.'}

        ,{'.','.','3', '.','.','8', '.','.','.'}
        ,{'.','1','2', '.','3','.', '.','.','.'}
        ,{'.','.','.', '.','.','7', '.','.','1'}};

        boolean b = solution.isValidSudoku(maps6);
        System.out.print(b);
    }

    class Solution {
        public boolean isValidSudoku(char[][] board) {
            for(int i = 0; i < board.length; i++) {
                for(int j = 0; j < board[0].length; j++) {
                    if(board[i][j] != '.') {
                        char target = board[i][j];
                        if(!isValid(board, i, j))
                            return false;
                    }
                }
            }
            return true;
        }

        private boolean isValid(char[][] board, int r, int c) {
            int rowOffset = (r/3)*3;
            int colOffset = (c/3)*3;
            for (int i = 0; i < 9; i++) {
                if (i != c && board[r][i] == board[r][c]) return false;
                if (i != r && board[i][c] == board[r][c]) return false;
                int row = (i/3 + rowOffset);
                int col = (i%3 + colOffset);
                if (row == r && col == c) continue;
                if (board[row][col] == board[r][c]) return false;
            }
            return true;
        }
    }
}
